# STRING_2
- 문자의 표현
- 문자열
- 연습문제
- 연산
- 패턴 매칭
- KMP 알고리즘
- 보이어 무어 알고리즘
- 문자열 암호화, 문자열 압축
## 문자의 표현
- 컴퓨터에서의 문자표현
    - 영어가 대소문자 합쳐서 52자이므로 6(64)비트면 모두 표현할 수 있다. 이를 코드 체계라고 한다.
        - 000000 -> 'a', 000001 -> 'b'
- 1967년 미국에서, **ASCII(American Standard Sode for Information Interchange)**라는 문자 인코딩 표준이 제정됨
- ASCII는 7-bit 인코딩으로 128문자를 표현하며 33개의 출력 불가능한 제어 문자들과 공백을 비롯한 95개의 출력 가능한 문자들로 이루어져 있다.
    - **A : 65, B : 66, C : 67, a : 97, b : 98, c : 99** ...
- **확장 아스키**는 표준 문자 이외의 악센트 문자, 도형 문자, 특수 문자, 특수 기호 등 부가적인 문자를 128개 추가할 수 있게 하는 부호이다.
    - 표준 아스키는 7-bit를 사용하여 문자를 표현하는 데 비해 확장 아스키는 1Byte 내의 8-bit를 모두 사용함으로써 추가적인 문자를 표현할 수 있다.
- 국가간 정보 전달에 비슷한 문제가 발생하여, 다국어 처리를 위해 마련된 표준안을 **유니코드**라고 한다.
    - 유니코드 인코딩(UTF : Unicode Transformation Format)
        - UTF-8 (in web)
            - MIN : 8bit, MAX : 32bit(1Byte * 4)
        - UTF-16 (in windows, java)
            - MIN : 16bit, MAX : 32bit(2BYTE * 2)
        - UTF-32 (in unix)
            - MIN : 32bit, MAX : 32bit(4Byte * 1)
## 문자열
- Python에서의 문자열 처리
    - char 타입 없음
    - 텍스트 데이터의 취급방법이 통일되어 있음
    - 문자열 기호
        - ', ", ''', """
        - +(연결) : 문자열 + 문자열 형태로 이어 붙여주는 역할
        - *(반복) : 문자열 * 수 형태로 수만큼 문자열이 반복
    - 문자열은 시퀀스 자료형으로 분류되고, 시퀀스 자료형에서 사용할 수 있는 인덱싱, 슬라이싱 연산들을 사용할 수 있음
    - 문자열 클래스에서 제공되는 메소드
        - replace(), split(), isalpha(), find()...
    - 문자열은 튜플과 같이 요소값을 변경할 수 없음(immutable)
- C와 Java의 String 처리의 기본적인 차이점
    - c는 아스키 코드로 저장한다.
    - java는 유니코드(UTF16, 2byte)로 저장한다.
    - 파이썬은 유니코드(UTF8) 로 저장한다.
- 문자열 뒤집기
    - 자기 문자열을 뒤집는 방법을 이용할 경우 swap을 위한 임시 변수가 필요하며 반복 수행을 문자열 길이의 반만을 수행해야 한다.
- 연습문제 1
```python
s = 'Reverse this strings'
s_lst = list(s)
n = len(s)

for i in range(n // 2):
    s_lst[i] ,s_lst[n - 1 - i] = s_lst[n - 1 - i], s_lst[i] 
s_reversed = "".join(s_lst)
print(s_reversed)
```
- 연습문제 2
```python
# 회문검사의 경우
# 연습문제 1과 같은 반복 조건을 작성한 뒤,
if s[i] == s[n - 1 - i]:
# 위 조건을 추가하여 해결할 수 있다.
```
## 연산
### 문자열 비교
- 파이썬은 == 연산자와 is 연산자를 제공한다.
- 문자열 비교함수 만들기
    - 문자열이 같으면 0 리턴
    - s1이 s2보다 사전 순서상 앞서면 -1 리턴
    - s1이 s2보다 사전 순서상 나중이면 1 리턴
    ```python
    def my_strcmp(s1, s2):
        if s1 < s2:
            return -1
        elif s1 > s2:
            return 1
        else:
            return 0
    ```
- int()와 같은 atoi()함수 만들기
```python
def atoi(s):
    i = 0
    for x in s:
        i = i*10 + ord(x)-ord('0')      # in ASCII, '0' = 48, '1' = 49, '2' = 50
    return i

s = '123'
a = atoi(s)
print(a + 1)            # 124       ## ord() 함수는 int를 반환한다
```
## 패턴 매칭
- 고지식한 패턴 검색 알고리즘
- 카프-라빈 알고리즘
- KMP 알고리즘
- 보이어-무어 알고리즘

### 고지식한 알고리즘(Brute Force)
- 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴내의 문자들을 일일이 비교하는 방식으로 동작
```python
p = "is"
t = "Thie is a book~!"
M = len(p)
N = len(t)

def BruteForce(p, t):
    i = 0
    j = 0
    while j < M and i < N:      # 탈출조건 : 패턴을 발견하거나 j == M, 실패하거나 i == N
        if t[i] != p[j]:
            i = i - j       # 탐색한 만큼을 초기화
            j = -1          # 처음으로 초기화
        i = i + 1       # +1 인덱스 만큼부터 다시 탐색 시작
        j = j + 1       # 0 인덱스 부터 다시 탐색 시작
    if j == M:              # 탐색 성공시,
        return i - M        # 발견된 패턴이 시작하는 위치 반환
    else:                   
        return -1           # 탐색 실패
```
- 고지식한 패턴 검색 알고리즘의 시간 복잡도
    - 최악의 경우 시간 복잡도는 텍스트의 모든 위치에서 패턴을 비교해야 하므로 **O(MN)**이 됨
### KMP 알고리즘
- 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 미리 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
- 패턴을 전처리하여 배열 next[M]을 구해서 잘못된 시작을 최소화함
    - next[M] : 불일치가 발생했을 경우 이동할 다음 위치
- 시간 복잡도 : O(M + N)

### 보이어 무어 알고리즘
- 오른쪽에어 왼쪽으로 비교
- 대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘
- 보이어-무어 알고리즘은 패턴에 오른쪽 긑에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이 만큼이 된다.
- 시간 복잡도
    - 최악의 경우: O(mn)
    - 일반적으로 O(n) 보다 시간이 덜 들게 된다.
---
- 연습문제 3
---
## 문자열 암호화 / 문자열 압축
- 시저 암호(Caesar cipher)